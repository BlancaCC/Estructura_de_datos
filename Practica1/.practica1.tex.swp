\documentclass[titlepage, 12pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}						%acentos y mierda
\usepackage[spanish, es-tabla]{babel}			%español
\usepackage{caption}							%fotos cortandose
\usepackage{listings}							%meter codigo 
\usepackage{adjustbox}							%coin no se acordaba
\usepackage{enumitem}							%listas mejoradas
\usepackage{amssymb, amsmath, amsthm}			%Los de matemáticas
\usepackage[margin=1in, top=0.7in]{geometry}	%Paquete de los margenes
\usepackage{xcolor}								%para definir tus propios colores
\usepackage{soul}								%coin no se acordaba
\usepackage{graphicx}
\graphicspath{ {/Estructura_de_datos/Images/} }
% Meta

\vspace{2cm}
\author{Pedro Bonilla Nadal, Sofía Almeida Bruno, Jesús Sáchez de Lechina Tejada}
\date{\small{}}

% Custom  
\providecommand{\abs}[1]{\lvert#1\rvert}
\setlength\parindent{0pt}
\definecolor{Light}{gray}{.90}
\newcommand\ddfrac[2]{\frac{\displaystyle #1}{\displaystyle #2}}
\setlist[description]{leftmargin=1em, labelindent=0.5em}

\begin{document}
\begin{titlepage}
	\vspace{1cm}
	\centering
	{\small II Doble Grado Ingieniería Infomática y Matemáticas  \par}
	\vspace{3.5cm}
	{\huge\bfseries  Estructura de Datos\par}
	\vspace{2.5cm}
	{\scshape\Large Práctica 1 - Eficiencia\par}
	\vspace{2cm}
	{\Large\itshape Pedro Bonilla Nadal, Sofía Almeida Bruno,  \par}
	{\Large\itshape Jesús Sánchez de Lechina Tejada \par}
	\vfill

	\vfill

% Bottom of the page
	{\large \par}
\end{titlepage}

	\textbf{\large Ejercicio 1.} El siguiente código realiza la ordenación mediante el algoritmo de la burbuja:\vspace {1em}
	
	\hspace*{1cm}1. void ordenar(int *v, int n) \{ \\
	\hspace*{1cm}2.\hspace*{2em}	for (int i=0; i<n-1; i++)\\
	\hspace*{1cm}3.\hspace*{4em}		for (int j=0; j $<$ n-i-1; j++) \{ \\
	\hspace*{1cm}4.\hspace*{6em}			if (v[j] $>$ v[j+1]) \{\\
	\hspace*{1cm}5.\hspace*{8em}				int aux = v[j];\\
	\hspace*{1cm}6.\hspace*{8em}				v[j] = v[j+1];\\
	\hspace*{1cm}7.\hspace*{8em}				v[j+1] = aux;\\
	\hspace*{1cm}8.\hspace*{6em}\} \\
	\hspace*{1cm}9.\hspace*{4em}\} \\
	\hspace*{1cm}10. \}  \vspace {1em} \\
Calcule la eficiencia teórica de este algoritmo. A continuación replique el experimento que se ha hecho antes (búsqueda lineal) con este nuevo código. Debe:\\ 
	\begin{itemize}  
	\item Crear un fichero ordenacion.cpp con el programa completo para realizar una
ejecución del algoritmo.
	\item Crear un fichero ejecuciones\_ordenación.csh que permite ejecutar varias veces el programa anterior y generar un fichero con los datos obtenidos. 
	\item Usar gnuplot para dibujar los datos obtenidos en el apartado previo.
	\end{itemize}
Los datos deben contener tiempos de ejecución para tamaños del vector 100, 600, 1100, \ldots,  30000. Pruebe a dibujar superpuestas la función con la eficiencia teórica y la empírica. ¿Qué sucede?\\

\underline{\emph{Solución.}}\\
El archivo ordenación.cpp y ejecuciones\_ordenacion.csh se encuentran adjuntos en la práctica.\\

\underline{Eficiencia teórica:} \\
	Línea 2: 5OE (2 asignaciones, 3 operaciones aritmético-lógica).\\
	Línea 3: 6OE (2 asignaciones, 4 operaciones aritmético-lógica).\\
	Línea 4-7: 13OE (6 accesos a vector, 4 operaciones artimético-lógicas, 3 asignaciones).\\

Entonces:= 1 + $\sum_{i=0}^{n-2}(5+\sum_{j=0}^{n-i-2}(5+13))= 1 + \sum_{i=0}^{n-2}(5+((n-i-2)*18))= \\
1 + \sum_{i=0}^{n-2}(5) + \sum_{i=0}^{n-2}(18n)+\sum_{i=0}^{n-2}(18n)+ \sum_{i=0}^{n-2}(18i) + \sum_{i=0}^{n-2}(18) = -4 + 4n + 9 n^2$.\\

\small{\underline{Nota:} debemos considerar que para ordenar un vector debe tener al menos 2 elementos.}

\newpage
  
%Ejercicio 5
\ 
  \textbf{\large Ejercicio 5.} Dependencia de la implementación:\\ 
  
  \hspace*{1cm}1. void ordenar(int *v, int n) \{ \\
  \hspace*{1cm}2.\hspace*{2em}  bool cambio=true;\\
  \hspace*{1cm}3.\hspace*{2em} 	for (int i=0; i$<$n-1 \&\& cambio; i++) \{ \\
  \hspace*{1cm}4.\hspace*{4em}      cambio=false; \{\\
  \hspace*{1cm}5.\hspace*{4em}      for (int j=0; j$<$n-i-1; j++)\{ \\
  \hspace*{1cm}6.\hspace*{6em}        if (v[j]$>$v[j+1]) \{\\
  \hspace*{1cm}7.\hspace*{8em}        cambio=true;\\
  \hspace*{1cm}8.\hspace*{8em}		  int aux = v[j]; \\
  \hspace*{1cm}9.\hspace*{8em}		  v[j] = v[j+1]; \\
  \hspace*{1cm}10.\hspace*{7em}		  $\ $v[j+1] = aux; \\
  \hspace*{1cm}11.\hspace*{6em}\} \\
  \hspace*{1cm}12.\hspace*{4em}\} \\
  \hspace*{1cm}13.\hspace*{2em}\} \\
  \hspace*{1cm}14. \}  \vspace {1em} \\

En ella se ha introducido una variable que permite saber si, en una de las iteraciones del bucle externo no se ha modificado el vector. Si esto ocurre significa que ya está ordenado y no hay que continuar.\\\\
Considere ahora la situación del mejor caso posible en la que el vector de entrada ya está ordenado. ¿Cuál sería la eficiencia teórica en ese mejor caso? Muestre la gráfica con la eficiencia empírica y compruebe si se ajusta a la previsión.
\\

\underline{Cálculo eficiencia teórica:}
\\\\
En cada línea de código se producen las siguientes operaciones elementales:

Línea 2: 1 o.e. inicialización booleana\\
Línea 3: 4 o.e. inicial. "$\ $i ", comparación "$<$", resta "n-1", incremento "$\ $i++"\\
Línea 4: 1 o.e. asignación booleana\\
Línea 5: 5 o.e. inicial. "j", comp. "$<$", doble resta "n-i-1", incremento "j++"\\\\
Línea 6: 4 o.e. accesos a v[j] y v[j+1], suma "j+1", comp. "$>$"\\
Línea 7: 1 o.e. asign. bool.\\
Línea 8: 2 o.e. inicial. "$\ $aux", acceso a v[j]\\
Línea 9: 4 o.e. acceso a v[j] y v[j+1], suma "j+1", asignación\\
Línea 10: 3 o.e. acceso a v[j+1], suma "j+1", asignación\\

*Las líneas 7-10 no sucederían en el mejor de los casos, cuando el vector está ordenado
\ 
\\\\ 
Por tanto, en el mejor de los casos, donde el primer bucle sólo produce una iteración:\\ 
$$T(n)=1\ +\ 1\ +\sum \limits_{j=0}^{n-1} 4= 1+1+(\frac{4+4}{2})\cdot(n-1)= 4n-2 $$
\newpage
\underline{Eficiencia práctica:}\\

\begin{figure}[!ht]
  \caption{Gráfica eficiencia práctica}
  \centering
    \includegraphics[width=0.5\textwidth]{./img/ef_pract_ej_5.png}
\end{figure}
\newpage
%Ejercicio 6

\textbf{\large Ejercicio 6.} Influencia del proceso de compilación:\\

Retome el ejercicio de ordenación mediante el algoritmo de la burbuja. Ahora replique
dicho ejercicio pero previamente deberá compilar el programa indicándole al compilador
que optimice el código. Esto se consigue así:
$$g++\ -O3\ ordenacion.cpp\ -o\ ordenacion\_optimizado$$
\\
Compare las curvas de eficiencia empírica para ver cómo mejora esto la eficiencia del
programa.
\\


\begin{figure}[!ht]
  \caption{Comparación ordenación normal/optimizado}
  \centering
    \includegraphics[width=0.5\textwidth]{./img/ef_pract_ej_6.png}
\end{figure}
 
\vspace {1em}  	


\end{document}
